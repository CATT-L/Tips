# Model 模型

## 基本概念

模型包含数据模型和抽象的业务模型，我们目前用到的只有数据模型。

有些框架会把这一层作为ORM（对象关系映射模型），我们把各种数据模型相关的东西放在这个目录下。



目前有：

- Dao 数据访问对象
- Cache 缓存访问对象
- Entity 数据实体（ORM 对象关系映射模型）
- Vo 值对象（Value Object 的缩写）



在 Java 的设计模式里，会有更多的类似这种东西，例如 POJO、DTO 之类的。但如果规范太多无疑会降低我们的开发效率，因此我们要做取舍，好用的东西拿过来用，不好用的就不照着做了。



## 什么时候用Entity,什么时候用Dao?

在我们的框架中，Entity 和 Dao 都是与数据库交互的代码。那么，应该用哪个呢？

我们优先用Entity数据实体，因为用起来很方便，而且可以在Entity上编写一些很方便的方法来读取关联数据（详情请查看官方文档）。

虽然Entity数据实体编写起来比较方便，但也有不适合使用或者无法使用的场景，这时候我们就采用Dao来编写数据库读写逻辑。



例如以下场景：

### 读写分离

我们并没有采用官方文档中的读写分离方案，而是手动填写了两个连接池配置，一个是读库、另一个是写库。

**不采用的原因**

> 经过多次测试，框架自带的读写分离配置，事务提交的时候存在BUG。
>
> 因此采用更加稳定的方案。
>
> 
>
> 除此之外，有一个数据库日志类，记录了从哪个连接池操作。



因此，在编写代码的过程中，并不是框架自动处理读写分离，而是我们手动在需要读从库的地方，手动指定读库的连接池读取。

而Entity默认数据源是业务主库的写库，因此，若需要从读库读取数据，只能编写Dao代码指定数据源读取。



### 非业务主库

其原因和上面说的一致，Entity默认数据源是业务主库。

但如果你细心阅读文档，会发现，Entity是有一个成员变量`$connection`来指定数据源的。

但是我们没有采用，原因是目前实体生成都混在一个目录里，如果一个目录里还有不同数据源的实体，那必然会导致项目代码混乱不堪。



### 动态表格

有些时候，数据表并不是一成不变的，而是随着代码执行动态修改的。

例如，把交易订单按日期归档，这个表名后缀，是程序动态生成的，表结构，也是程序从模板表读取出来的。

因此，这样的表，我们并不能硬编码成一个Entity实体，其自身的读写过程就是一个复杂的逻辑。

这种时候，我们要选择Dao编写。



### 复杂查询

有的场景，使用查询构造器甚至原生SQL语句，写出来的代码，会比Entity更加简洁。

这些场景通常是一些复杂的查询，例如一个查询需要关联若干张表、又比如统计汇总数据。

这时候用Entity来编写的话，其代码复杂无比。

这种时候，我们也选择Dao编写。